//==========================================================================================================================
//Key is used to ensure the consistency of file version and content, and cannot be modified.
//Version Control is the version number written when the file is generated and cannot be modified.
//ToolMessage is used to record related information of any tool that has processed the file and cannot be manually modified.
//UserMessage is used by the user to write any information, which can be modified in any way.
//Content is the actual payload of the file.
//Parameter is the additional parameter information carried by the file and cannot be modified in any way.

//Key is generated by the hash of Version Control, Content and Parameter to ensure the consistency of the file.
//These three parts do not allow any individual modification
//==========================================================================================================================


//[UHDL]Key Start [md5:1bd00419061011c95aca8323671385ba]
//Version Control Hash: 3accddf64b1dd03abeb9b0b3e5a7ba44
//Content Hash: 111ae4bd44471d2c2781e1b3f14d99f9
//Parameter Hash: d41d8cd98f00b204e9800998ecf8427e
//[UHDL]Key End [md5:1bd00419061011c95aca8323671385ba]

//[UHDL]Version Control Start [md5:3accddf64b1dd03abeb9b0b3e5a7ba44]
//[UHDL]Version Control Version:1.0.1
//[UHDL]Version Control End [md5:3accddf64b1dd03abeb9b0b3e5a7ba44]

//[UHDL]Tool Message Start [md5:136c2ca90c4703b692ea0470be1feb9c]
//Written by UHDL in 2023-07-10 10:19:50
//[UHDL]Tool Message End [md5:136c2ca90c4703b692ea0470be1feb9c]

//[UHDL]User Message Start [md5:d41d8cd98f00b204e9800998ecf8427e]

//[UHDL]User Message End [md5:d41d8cd98f00b204e9800998ecf8427e]

//[UHDL]Content Start [md5:111ae4bd44471d2c2781e1b3f14d99f9]
module RegSpaceRTL_cfg_reg_bank_B (
	input             clk                ,
	input             rst_n              ,
	input      [31:0] p_addr             ,
	input      [2:0]  p_prot             ,
	input             p_sel              ,
	input             p_enable           ,
	input             p_write            ,
	input      [31:0] p_wdata            ,
	input      [3:0]  p_strb             ,
	output            p_ready            ,
	output reg [31:0] p_rdata            ,
	output            p_slverr           ,
	input             reg0_field0_wdat   ,
	input             reg0_field0_wenable,
	output            reg0_field0_rdat   ,
	input             reg0_field1_wdat   ,
	input             reg0_field1_wenable,
	output            reg0_field1_rdat   ,
	input             reg0_field2_wdat   ,
	input             reg0_field2_wenable,
	output            reg0_field2_rdat   ,
	output            reg0_field3_rdat   ,
	input             reg0_field4_wdat   ,
	input             reg0_field4_wenable,
	input             reg0_field5_wdat   ,
	input             reg0_field5_wenable,
	output            reg0_field5_rdat   ,
	input      [1:0]  reg0_field6_wdat   ,
	input             reg0_field6_wenable,
	output     [1:0]  reg0_field6_rdat   ,
	input             reg1_field0_wdat   ,
	input             reg1_field0_wenable,
	output            reg1_field0_rdat   ,
	input             reg1_field1_wdat   ,
	input             reg1_field1_wenable,
	output            reg1_field1_rdat   ,
	input             reg1_field2_wdat   ,
	input             reg1_field2_wenable,
	output            reg1_field2_rdat   ,
	output            reg1_field3_rdat   ,
	input             reg1_field4_wdat   ,
	input             reg1_field4_wenable,
	input             reg1_field5_wdat   ,
	input             reg1_field5_wenable,
	output            reg1_field5_rdat   ,
	input      [1:0]  reg1_field6_wdat   ,
	input             reg1_field6_wenable,
	output     [1:0]  reg1_field6_rdat   );
	reg  [31:0] reg0_rdat  ;
	wire [0:0]  reg0_rrdy  ;
	wire [31:0] reg0_wdat  ;
	wire [0:0]  reg0_wvld  ;
	reg  [0:0]  reg0_field0;
	reg  [0:0]  reg0_field1;
	reg  [0:0]  reg0_field2;
	reg  [0:0]  reg0_field3;
	reg  [0:0]  reg0_field4;
	reg  [0:0]  reg0_field5;
	reg  [1:0]  reg0_field6;
	reg  [31:0] reg1_rdat  ;
	wire [0:0]  reg1_rrdy  ;
	wire [31:0] reg1_wdat  ;
	wire [0:0]  reg1_wvld  ;
	reg  [0:0]  reg1_field0;
	reg  [0:0]  reg1_field1;
	reg  [0:0]  reg1_field2;
	reg  [0:0]  reg1_field3;
	reg  [0:0]  reg1_field4;
	reg  [0:0]  reg1_field5;
	reg  [1:0]  reg1_field6;
	reg  [0:0]  p_ready_r  ;
	assign p_ready = p_ready_r;
	
	always @(*) begin
	    if((p_addr == 32'b0)) p_rdata = reg0_rdat;
	    else if((p_addr == 32'b1)) p_rdata = reg1_rdat;
	    else p_rdata = 32'b0;
	end
	
	assign p_slverr = 1'b0;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_rdat <= 32'b0;
	    else begin
	        if((((!p_write) && p_sel && p_enable && (p_addr == 32'b0)))) reg0_rdat <= {reg0_field0, 2'b0, 1'b0, 1'b0, reg0_field2, 1'b0, reg0_field3, 1'b0, reg0_field4, 1'b0, reg0_field5, 1'b0, reg0_field6, 17'b0};
	        else reg0_rdat <= 32'b0;
	    end
	end
	
	assign reg0_rrdy = ((!p_write) && p_sel && p_enable && (p_addr == 32'b0));
	
	assign reg0_wdat = p_wdata;
	
	assign reg0_wvld = (p_write && p_sel && p_enable && (p_addr == 32'b0));
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field0 <= 1'b0;
	    else begin
	        if(reg0_field0_wenable) reg0_field0 <= reg0_field0_wdat;
	    end
	end
	
	assign reg0_field0_rdat = reg0_field0;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field1 <= 1'b0;
	    else begin
	        if(reg0_field1_wenable) reg0_field1 <= reg0_field1_wdat;
	        else if(reg0_wvld) reg0_field1 <= reg0_wdat[3:3];
	    end
	end
	
	assign reg0_field1_rdat = reg0_field1;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field2 <= 1'b0;
	    else begin
	        if(reg0_field2_wenable) reg0_field2 <= reg0_field2_wdat;
	        else if(reg0_wvld) reg0_field2 <= reg0_wdat[5:5];
	    end
	end
	
	assign reg0_field2_rdat = reg0_field2;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field3 <= 1'b0;
	    else begin
	        if(reg0_wvld) reg0_field3 <= reg0_wdat[7:7];
	    end
	end
	
	assign reg0_field3_rdat = reg0_field3;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field4 <= 1'b0;
	    else begin
	        if(reg0_field4_wenable) reg0_field4 <= reg0_field4_wdat;
	        else if(reg0_wvld) reg0_field4 <= reg0_wdat[9:9];
	    end
	end
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field5 <= 1'b0;
	    else begin
	        if(reg0_field5_wenable) reg0_field5 <= reg0_field5_wdat;
	        else if(reg0_wvld) reg0_field5 <= reg0_wdat[11:11];
	    end
	end
	
	assign reg0_field5_rdat = reg0_field5;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg0_field6 <= 2'b0;
	    else begin
	        if(reg0_field6_wenable) reg0_field6 <= reg0_field6_wdat;
	        else if(reg0_wvld) reg0_field6 <= reg0_wdat[14:13];
	        else if(reg0_rrdy) reg0_field6 <= 2'b0;
	    end
	end
	
	assign reg0_field6_rdat = reg0_field6;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_rdat <= 32'b0;
	    else begin
	        if((((!p_write) && p_sel && p_enable && (p_addr == 32'b1)))) reg1_rdat <= {reg1_field0, 2'b0, 1'b0, 1'b0, reg1_field2, 1'b0, reg1_field3, 1'b0, reg1_field4, 1'b0, reg1_field5, 1'b0, reg1_field6, 17'b0};
	        else reg1_rdat <= 32'b0;
	    end
	end
	
	assign reg1_rrdy = ((!p_write) && p_sel && p_enable && (p_addr == 32'b1));
	
	assign reg1_wdat = p_wdata;
	
	assign reg1_wvld = (p_write && p_sel && p_enable && (p_addr == 32'b1));
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field0 <= 1'b0;
	    else begin
	        if(reg1_field0_wenable) reg1_field0 <= reg1_field0_wdat;
	    end
	end
	
	assign reg1_field0_rdat = reg1_field0;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field1 <= 1'b0;
	    else begin
	        if(reg1_field1_wenable) reg1_field1 <= reg1_field1_wdat;
	        else if(reg1_wvld) reg1_field1 <= reg1_wdat[3:3];
	    end
	end
	
	assign reg1_field1_rdat = reg1_field1;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field2 <= 1'b0;
	    else begin
	        if(reg1_field2_wenable) reg1_field2 <= reg1_field2_wdat;
	        else if(reg1_wvld) reg1_field2 <= reg1_wdat[5:5];
	    end
	end
	
	assign reg1_field2_rdat = reg1_field2;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field3 <= 1'b0;
	    else begin
	        if(reg1_wvld) reg1_field3 <= reg1_wdat[7:7];
	    end
	end
	
	assign reg1_field3_rdat = reg1_field3;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field4 <= 1'b0;
	    else begin
	        if(reg1_field4_wenable) reg1_field4 <= reg1_field4_wdat;
	        else if(reg1_wvld) reg1_field4 <= reg1_wdat[9:9];
	    end
	end
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field5 <= 1'b0;
	    else begin
	        if(reg1_field5_wenable) reg1_field5 <= reg1_field5_wdat;
	        else if(reg1_wvld) reg1_field5 <= reg1_wdat[11:11];
	    end
	end
	
	assign reg1_field5_rdat = reg1_field5;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) reg1_field6 <= 2'b0;
	    else begin
	        if(reg1_field6_wenable) reg1_field6 <= reg1_field6_wdat;
	        else if(reg1_wvld) reg1_field6 <= reg1_wdat[14:13];
	        else if(reg1_rrdy) reg1_field6 <= 2'b0;
	    end
	end
	
	assign reg1_field6_rdat = reg1_field6;
	
	always @(posedge clk or negedge rst_n) begin
	    if(~rst_n) p_ready_r <= 1'b0;
	    else begin
	        if((reg1_wvld || reg1_rrdy)) p_ready_r <= 1'b1;
	        else p_ready_r <= 1'b0;
	    end
	end
	

endmodule
//[UHDL]Content End [md5:111ae4bd44471d2c2781e1b3f14d99f9]

//[UHDL]Parameter Start [md5:d41d8cd98f00b204e9800998ecf8427e]

//[UHDL]Parameter End [md5:d41d8cd98f00b204e9800998ecf8427e]

